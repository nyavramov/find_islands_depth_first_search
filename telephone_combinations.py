class Solution:
    def letterCombinations(self, digits: 'str') -> 'List[str]':
        
        # We'll use this to store each combination of letters generated by the search
        combinations = []

        # We'll map a number on the telephone dialpad to a series of letters in the alphabet
        digit_letter_map = { '2' : 'abc',
                             '3' : 'def', 
                             '4' : 'ghi',
                             '5' : 'jkl',
                             '6' : 'mno', 
                             '7' : 'pqrs',
                             '8' : 'tuv',
                             '9' : 'wxyz' }

        # Use this temporary string to build up the individual combinations
        temp = ""

        self.depth_first_search(digits, 0, temp, digit_letter_map, combinations)

        return combinations

    # digits will store what telephone digit we're expanding
    # index will keep track of which digits we've visited
    # temp will store individual combinations and will be appended to combinations 
    # combinations will store the combination of letters generated by the search
    def depth_first_search(self, digits, index, temp, digit_letter_map, combinations):
        # We know we're done when we've reached the very last digit in the input
        if index == len(digits):
            combinations.append(temp)
        else:
            # Take a look at what digit we're on then get its corresponding letters
            digit = digits[index]
            letters = digit_letter_map[digit]

            # For each letter, expand the subtree of digits
            for letter in letters:
                self.depth_first_search(digits, index+1, temp+letter, digit_letter_map, combinations)

# Create a new solution and print out the results
solution = Solution()
print(solution.letterCombinations("23"))
